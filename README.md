# Tomasulo

### 基本假设
* 我们不对register和内存中的初始值做任何假设，所以所有对他们的取值都将获得一个string来指示其“表面值”，比如Reg[F1]，或者Mem[x1+32]
* 为了简化项目，我们不另外创建功能单元类（即memory unit、adder、multiplier等），而是直接将他们整合到RS或LoadBuffer部件中，所以写CDB的过程也将由这些类RS部件来完成
* 写CDB实际上就是将result值传送给其它部件，比如Add2完成了计算得到一个result，那么写CDB就是将所有依赖Add2的部件，全部改写为这个result。但需要注意的是，CDB并不会（也不应该）显式修改他们的状态（比如因为操作数已经ready，所以从issue状态转变为execute状态），这些状态的转变需要由这些部件本身来完成，CDB只负责传输数据。
* register有value和occupiedUnit这两个字段，在该register为busy的时候，则返回occupiedUnit（即对该register的访问都应转变为对另一个部件的访问）；仅当register为free的时候，才会直接获得它的值。
* 功能单元采用“类FIFO”式的服务，即在所有已经ready的instruction中，保证先到的一定先服务
* 有一个关键的设计：比如某条指令，在第3周期完成，在第4周期写回，那么第4周期的时候，依赖这个result的所有指令才能拿到这个数，然后就可以进行对应的操作了。所以在这个模拟系统中，我们会在第3周期的时候，将数据送进CDB，然后CDB在第4周期的最初，将所有数据传送给其它组件，从而实现符合实际情况的设计。


### 需要注意的点
* 因为本项目都是用字面值，所以值太长的话（比如Mem[44 + Regs[x3]] - Mem[32 + Regs[x2]]这种），有可能会导致output的时候出错（因为使用了格式化输出来控制），如果需要调整的话，后期我可以增加一个“输入”模块，即对某些内存地址进行赋值（那我们就需要实现一个memory模块了）
